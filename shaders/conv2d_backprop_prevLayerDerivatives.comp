#version 440

layout(local_size_x_id = 0) in; // workgroup dimensions specialization constants
layout(push_constant) uniform Parameters {  // push constants
	int batch_size, h, w, c, filters, size, stride, padding, out_h, out_w, useBias; float learning_rate;
} p;

layout(std430, binding = 0) buffer lay0 { float weights[]; }; 
layout(std430, binding = 1) buffer lay1 { float derivatives[]; };
layout(std430, binding = 2) buffer lay2 { float prev_derivatives[]; };

void main(){
  const uint k = gl_GlobalInvocationID.x;  // input channel
  if(k >= p.c){
      return;
  }
  
  int h_offset = -p.padding / 2;
  int w_offset = -p.padding / 2;
  
	for (int b = 0; b < p.batch_size; b++) {
		for (int i = 0; i < p.h; i++) {
			for (int j = 0; j < p.w; j++) {
					float res = 0;
					int startI = (i - p.size + 1 - h_offset) / p.stride;
					int startJ = (j - p.size + 1 - w_offset) / p.stride;
					for (int ii = max(startI, 0); ii < min(startI + p.size, p.out_h); ii++) {
						for (int jj = max(startJ, 0); jj < min(startJ + p.size, p.out_w); jj++) {
							for (int kk = 0; kk < p.filters; kk++) {
								float derivativesValue = derivatives[b * p.out_h * p.out_w * p.filters + ii * p.out_w * p.filters + jj * p.filters + kk];
								int kI = ii - startI;
								int kJ = jj - startJ;
								kI = p.size - 1 - kI;
								kJ = p.size - 1 - kJ;
								float kernelValue = weights[kI * p.size * p.c * p.filters +
									kJ * p.c * p.filters + k * p.filters + kk];
								res += derivativesValue * kernelValue;
							}
						}
					}
					prev_derivatives[b * p.h * p.w * p.c + i * p.w * p.c + j * p.c + k] = res;
			}
		}
	}
  
}

